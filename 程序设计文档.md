# 纸牌消除游戏程序设计文档

## 1. 项目概述

本项目是一个基于Cocos2d-x 3.17.2开发的纸牌消除游戏Demo，采用经典MVC架构设计，实现三个核心功能：手牌区翻牌替换、桌面牌匹配消除和操作回退功能。项目规模适中，但涵盖了游戏开发的核心技术要素，包括状态管理、用户交互、动画系统和数据持久化。

## 2. 技术架构设计

### 2.1 整体架构

项目采用MVC（Model-View-Controller）经典架构模式，实现各层次职责分离：

- **Model层**：专注于数据存储和业务逻辑，不包含UI相关代码
- **View层**：负责UI显示和用户输入接收，通过回调机制与Controller通信
- **Controller层**：作为Model和View的协调者，处理业务逻辑和用户交互流程

### 2.2 目录结构

```
Classes/
├── configs/           # 配置系统
│   ├── models/        # 配置数据模型
│   └── loaders/       # 配置加载器
├── models/            # 运行时数据模型
├── views/             # UI视图组件
├── controllers/       # 业务逻辑控制器
├── managers/          # 功能管理器
├── services/          # 无状态服务
└── utils/             # 工具类和类型定义
```

### 2.3 核心类设计

| 层级 | 主要类 | 职责描述 |
|------|--------|----------|
| 应用入口 | AppDelegate, HelloWorldScene | 应用初始化和场景管理 |
| 控制器 | GameController | 主控制器，协调整个游戏流程 |
| 控制器 | StackController, PlayFieldController | 功能子控制器 |
| 视图 | GameView, CardView | UI显示和交互 |
| 模型 | GameModel, CardModel | 数据存储和业务逻辑 |
| 管理器 | GameMemory | 状态管理和回退功能 |

## 3. 核心数据模型

### 3.1 卡牌模型 (CardModel)

卡牌模型是整个系统的核心数据结构，定义如下：

```cpp
class CardModel {
private:
    int _cardId;                    // 唯一标识符
    CardFaceType _faceType;         // 面值 (A=0, 2=1, ..., K=12)
    CardSuitType _suitType;         // 花色 (梅花=0, 方块=1, 红心=2, 黑桃=3)
    cocos2d::Vec2 _position;        // 位置坐标
    bool _isFlipped;                // 显示状态
};
```

关键方法：
- `canMatchWith()`：匹配逻辑，检查面值差是否为1
- 标准的getter/setter方法用于数据访问

### 3.2 游戏模型 (GameModel)

游戏模型管理所有卡牌的运行时状态：

```cpp
class GameModel {
private:
    std::vector<CardModel*> _playfieldCards;    // 游戏区域卡牌
    std::vector<CardModel*> _stackCards;        // 备用堆叠
    std::vector<CardModel*> _handStackCards;    // 手牌堆叠
    std::map<int, CardModel*> _cardMap;         // ID映射
};
```

核心功能：
- 卡牌位置和状态管理
- 可见性计算（覆盖关系判断）
- 堆叠操作（增删移动）

## 4. 配置系统设计

### 4.1 配置数据结构

采用JSON格式的外部配置文件，支持关卡数据的灵活定义：

```json
{
    "Playfield": [
        {"CardFace": 4, "CardSuit": 2, "Position": {"x": 260, "y": 1100}}
    ],
    "Stack": [
        {"CardFace": 5, "CardSuit": 2, "Position": {"x": 0, "y": 0}}
    ]
}
```

### 4.2 配置加载流程

1. **文件读取**：使用Cocos2d-x FileUtils读取JSON文件
2. **数据解析**：基于rapidjson库解析配置数据
3. **对象创建**：实例化LevelConfig和CardConfig对象
4. **模型生成**：通过GameModelFromLevelGenerator创建运行时模型

## 5. 视图层设计

### 5.1 卡牌视图 (CardView)

卡牌视图负责单个卡牌的显示和交互：

**组成元素**：
- 背景精灵 (card_general.png)
- 花色图标 (club.png, diamond.png等)
- 大号数字 (big_red_A.png, big_black_2.png等)
- 小号角落数字
- 背面精灵

**交互处理**：
- 触摸事件监听
- 仅正面朝上的卡牌响应点击
- 通过回调机制通知Controller

### 5.2 动画系统

采用动画完成回调模式确保视觉效果与数据状态同步：

```cpp
void CardView::playMoveAnimation(const Vec2& targetPos,
                                const std::function<void()>& callback) {
    auto moveTo = MoveTo::create(duration, targetPos);
    if (callback) {
        auto sequence = Sequence::create(moveTo,
                        CallFunc::create(callback), nullptr);
        runAction(sequence);
    }
}
```

## 6. 控制器层设计

### 6.1 主控制器 (GameController)

作为MVC架构的协调者，GameController负责：

1. **初始化流程**：加载配置→生成模型→创建视图→初始化子控制器
2. **事件分发**：将用户操作路由到相应的子控制器
3. **状态同步**：确保Model和View状态的一致性

### 6.2 功能子控制器

- **StackController**：管理手牌区翻牌替换逻辑
- **PlayFieldController**：管理桌面牌匹配消除逻辑

每个子控制器都遵循单一职责原则，专注于特定的游戏功能。

## 7. 状态管理机制

### 7.1 回合状态设计

采用完整状态快照的方式实现回退功能：

```cpp
class RoundState {
private:
    CardStackState _handStack;        // 手牌堆叠状态
    CardStackState _alternativeStack; // 备用堆叠状态
    CardStackState _mainStack;        // 主堆叠状态
};
```

### 7.2 内存管理器 (GameMemory)

GameMemory类提供完整的状态管理功能：

- **状态捕获**：`captureCurrentState()` 保存当前游戏状态
- **状态恢复**：`restoreState()` 将游戏回退到指定状态
- **回合导航**：支持前进和后退操作
- **内存管理**：自动清理历史状态，避免内存泄漏

## 8. 新增卡牌的设计方案

### 8.1 扩展点分析

在当前架构下，新增卡牌需要考虑以下几个方面：

1. **数据层扩展**：卡牌属性和匹配逻辑
2. **配置层扩展**：关卡配置格式
3. **视图层扩展**：显示资源和布局
4. **逻辑层扩展**：匹配规则和游戏逻辑

### 8.2 具体实现步骤

#### 步骤1：定义新的卡牌类型

在GameTypes.h中扩展枚举类型：

```cpp
// 新增卡牌面值类型
enum CardFaceType {
    FACE_A = 0,    // A
    FACE_2 = 1,    // 2
    // ... 现有定义 ...
    FACE_JOKER = 13  // 新增Joker牌
};

// 新增卡牌花色类型（如果需要）
enum CardSuitType {
    SUIT_CLUB = 0,     // 梅花
    SUIT_DIAMOND = 1,  // 方块
    // ... 现有定义 ...
    SUIT_JOKER = 4     // Joker花色
};
```

#### 步骤2：扩展匹配逻辑

在CardModel::canMatchWith()方法中添加新的匹配规则：

```cpp
bool CardModel::canMatchWith(const CardModel* otherCard) const {
    if (!otherCard) return false;

    // Joker牌可以与任何牌匹配
    if (_faceType == FACE_JOKER || otherCard->getFaceType() == FACE_JOKER) {
        return true;
    }

    // 普通牌的匹配逻辑（面值差为1）
    int diff = std::abs(static_cast<int>(_faceType) -
                       static_cast<int>(otherCard->getFaceType()));
    return (diff == 1);
}
```

#### 步骤3：扩展资源配置

在CardResConfig类中添加新的资源路径映射：

```cpp
// 新增Joker牌的资源路径
std::string CardResConfig::getBigNumberPath(CardFaceType face, CardSuitType suit) {
    if (face == FACE_JOKER) {
        return "res/number/big_joker.png";
    }

    // 原有逻辑保持不变
    std::string colorPrefix = isRedSuit(suit) ? "big_red_" : "big_black_";
    std::string faceStr = getFaceString(face);
    return "res/number/" + colorPrefix + faceStr + ".png";
}
```

#### 步骤4：更新配置加载器

修改LevelConfigLoader以支持新的卡牌类型：

```cpp
CardConfig LevelConfigLoader::parseCardConfig(const rapidjson::Value& cardJson) {
    CardConfig config;

    // 解析面值，支持字符串格式的JOKER
    if (cardJson["CardFace"].IsString()) {
        std::string faceStr = cardJson["CardFace"].GetString();
        if (faceStr == "JOKER") {
            config.cardFace = FACE_JOKER;
        }
    } else {
        config.cardFace = static_cast<CardFaceType>(cardJson["CardFace"].GetInt());
    }

    // 解析花色，类似处理
    // ...

    return config;
}
```

#### 步骤5：更新视图显示逻辑

在CardView::updateDisplay()中添加对新卡牌类型的支持：

```cpp
void CardView::updateDisplay() {
    bool isFaceUp = _cardModel->isFlipped();

    // Joker牌使用特殊显示逻辑
    if (_cardModel->getFaceType() == FACE_JOKER) {
        // 显示Joker专用资源
        _suitSprite->setTexture("res/suits/joker.png");
        _bigNumberSprite->setTexture("res/number/big_joker.png");
    } else {
        // 原有逻辑保持不变
        // ...
    }

    // 其余显示逻辑保持不变
    // ...
}
```

### 8.3 配置示例

更新后的JSON配置格式：

```json
{
    "Playfield": [
        {"CardFace": 4, "CardSuit": 2, "Position": {"x": 260, "y": 1100}},
        {"CardFace": "JOKER", "CardSuit": "JOKER", "Position": {"x": 460, "y": 1100}}
    ],
    "Stack": [
        {"CardFace": 5, "CardSuit": 2, "Position": {"x": 0, "y": 0}}
    ]
}
```

## 9. 新增回退功能类型的设计方案

### 9.1 当前回退机制分析

现有的回退功能基于完整状态快照，优点是实现简单可靠，但存在以下限制：

1. 只能逐回合回退，无法跳跃
2. 内存占用与回合数量成正比
3. 不支持选择性回退（如只回退特定操作）

### 9.2 扩展方案设计

#### 方案1：操作命令模式回退

**设计思路**：
采用命令模式记录每个操作的具体内容，而不是保存完整状态。

**新增类设计**：

```cpp
class GameCommand {
public:
    virtual ~GameCommand() {}
    virtual void execute() = 0;        // 执行操作
    virtual void undo() = 0;          // 撤销操作
    virtual CommandType getType() const = 0;  // 获取命令类型
};

class MoveCardCommand : public GameCommand {
private:
    int _cardId;
    Vec2 _fromPos;
    Vec2 _toPos;
    // 其他必要状态

public:
    void execute() override {
        // 执行移动逻辑
    }

    void undo() override {
        // 撤销移动逻辑
    }
};
```

**实现步骤**：

1. **创建命令接口**：定义GameCommand基类
2. **实现具体命令类**：MoveCardCommand, FlipCardCommand等
3. **扩展GameMemory**：添加命令历史记录功能
4. **修改控制器**：将操作封装为命令对象
5. **实现选择性回退**：支持撤销特定类型的操作

#### 方案2：时间旅行式回退

**设计思路**：
支持在历史状态间自由跳转，可以"时光旅行"到任意历史时刻。

**核心实现**：

```cpp
class TimeTravelMemory {
private:
    std::vector<RoundState*> _timeline;    // 时间线
    int _currentTimeIndex;                 // 当前时间点

public:
    // 跳转到指定时间点
    bool jumpToTime(int timeIndex);

    // 获取时间线信息
    const std::vector<RoundState*>& getTimeline() const;

    // 清理未来时间线（当在历史点进行新操作时）
    void truncateFuture();
};
```

**优势**：
- 支持非线性回退
- 可以预览历史状态
- 支持书签功能（保存重要状态点）

### 9.3 推荐实现方案

基于项目的规模和复杂度，建议优先实现**操作命令模式回退**，原因如下：

1. **渐进式扩展**：可以在现有架构基础上逐步实现
2. **性能优化**：减少内存占用，避免存储完整状态
3. **功能增强**：支持更细粒度的操作控制
4. **维护性**：代码结构更清晰，易于测试和调试

### 9.4 具体实现步骤

#### 步骤1：定义命令接口

```cpp
// 新增文件：models/commands/GameCommand.h
class GameCommand {
public:
    virtual ~GameCommand() {}
    virtual void execute(GameModel* model) = 0;
    virtual void undo(GameModel* model) = 0;
    virtual CommandType getType() const = 0;
    virtual std::string getDescription() const = 0;  // 用于日志和UI显示
};
```

#### 步骤2：实现具体命令类

```cpp
// 新增文件：models/commands/MoveCardCommand.h
class MoveCardCommand : public GameCommand {
private:
    int _cardId;
    Vec2 _oldPos;
    Vec2 _newPos;

public:
    MoveCardCommand(int cardId, const Vec2& oldPos, const Vec2& newPos)
        : _cardId(cardId), _oldPos(oldPos), _newPos(newPos) {}

    void execute(GameModel* model) override {
        CardModel* card = model->getCardById(_cardId);
        if (card) {
            card->setPosition(_newPos);
        }
    }

    void undo(GameModel* model) override {
        CardModel* card = model->getCardById(_cardId);
        if (card) {
            card->setPosition(_oldPos);
        }
    }

    CommandType getType() const override { return CMD_MOVE_CARD; }
};
```

#### 步骤3：扩展状态管理器

```cpp
// 修改GameMemory类，添加命令历史支持
class GameMemory {
private:
    std::vector<GameCommand*> _commandHistory;  // 命令历史
    int _currentCommandIndex;                   // 当前命令索引

public:
    // 执行并记录命令
    void executeCommand(GameCommand* command);

    // 撤销最后一个命令
    bool undoLastCommand();

    // 撤销特定类型的命令
    bool undoCommandOfType(CommandType type);

    // 获取命令历史
    const std::vector<GameCommand*>& getCommandHistory() const;
};
```

#### 步骤4：修改控制器逻辑

```cpp
// 在StackController中修改替换逻辑
void StackController::replaceTopTrayCard(int cardId) {
    // 记录操作前的状态
    CardModel* card = _gameModel->getCardById(cardId);
    Vec2 oldPos = card->getPosition();
    Vec2 newPos = _gameModel->getTopTrayCard()->getPosition();

    // 创建移动命令
    MoveCardCommand* moveCmd = new MoveCardCommand(cardId, oldPos, newPos);
    RemoveFromStackCommand* removeCmd = new RemoveFromStackCommand(cardId);
    AddToHandStackCommand* addCmd = new AddToHandStackCommand(cardId);

    // 创建复合命令
    CompositeCommand* replaceCmd = new CompositeCommand();
    replaceCmd->addCommand(moveCmd);
    replaceCmd->addCommand(removeCmd);
    replaceCmd->addCommand(addCmd);

    // 执行命令
    _gameMemory->executeCommand(replaceCmd);

    // 其余动画和视图更新逻辑保持不变
    // ...
}
```

#### 步骤5：UI扩展

为新回退功能添加相应的UI控件：

- **撤销按钮**：撤销最后一个操作
- **重做按钮**：重做已撤销的操作  
- **历史面板**：显示操作历史，支持点击跳转
- **类型过滤**：只撤销特定类型的操作

## 10. 总结

本项目展示了良好的软件工程实践，通过MVC架构实现了代码的模块化和可维护性。新增卡牌和新类型回退功能的设计方案充分考虑了现有架构的扩展性，既保持了系统的稳定性，又提供了灵活的功能扩展能力。这些设计方案体现了在实际项目开发中平衡技术债务和功能需求的考量。
